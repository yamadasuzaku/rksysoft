# XRISM Resolve Detect Pseudo Events and Clustering Tool

## Overview

`resolve_ftools_detect_pseudo_event_clusters.py` is a Python-based tool designed to **identify and annotate pseudo events** in X-ray event data from XRISM’s **Resolve** instrument.

> **Naming note**  
> `resolve_ftools_add_cluster.py` is the **legacy name** of this tool. The current maintained implementation is
> `resolve_ftools_detect_pseudo_event_clusters.py`.

Pseudo events are detector triggers that are **not caused by astrophysical X-ray photons**, but instead originate from **cosmic-ray interactions, electronics response, waveform subtraction artifacts, or algorithmic edge cases**. While Resolve already flags known cross-talk events, this tool extends the capability to identify **time-correlated event structures** that are inconsistent with independent astrophysical photons.

The clustering algorithm operates **per pixel**, grouping events that occur within short temporal windows and annotating them with cluster metadata. The output FITS file preserves all original rows and columns, while adding cluster-related diagnostic columns that allow downstream screening, grade studies, and exposure evaluation.

This script is typically used as part of the shell pipeline:

```bash
./run_cluster_pipeline.sh <input_file_uf.evt>
````

Please read **before running**:

* `README_cluster_pipeline.md`

---

## Repository location (current script)

* `resolve_ftools_detect_pseudo_event_clusters.py`
  [https://github.com/yamadasuzaku/rksysoft/blob/main/resolve/ftools/rslcluster/resolve_ftools_detect_pseudo_event_clusters.py](https://github.com/yamadasuzaku/rksysoft/blob/main/resolve/ftools/rslcluster/resolve_ftools_detect_pseudo_event_clusters.py)

---

## Dependencies

* Python 3.x
* NumPy
* Astropy
* Matplotlib (optional, for diagnostics)

No proprietary XRISM software is required. The tool operates on standard FITS event files.

---

## Usage

### Recommended usage (pipeline)

```bash
./run_cluster_pipeline.sh <input_file_uf.evt>
```

Within the pipeline, `resolve_ftools_detect_pseudo_event_clusters.py` is invoked sequentially in
**large** and **small** clustering modes (see the pipeline README for file naming details).

### Direct invocation example

```bash
resolve_ftools_detect_pseudo_event_clusters.py clean.evt \
  --mode small \
  --col_cluster ICLUSTERS \
  --col_member IMEMBERS \
  --outname small_ \
  -d
```

---

## Arguments (summary)

### Required

* `input_fits`
  Input FITS event file (EVENTS table in HDU=1).
  The file must already contain `PREV_INTERVAL` and `NEXT_INTERVAL` columns generated by
  `resolve_ftools_add_prevnext.sh`.

### Core options

* `--mode {large,small}`
  Clustering mode:

  * **large**: anchor on **large-amplitude Lp** triggers to detect particle-like clusters
  * **small**: detect **subtle pseudo events** consistent with waveform subtraction residuals and special forced-trigger populations (e.g., `NEXT_INTERVAL == 75` or `105`)

* `--usepixels` / `-p`
  Comma-separated pixel list (default: 0\UTF{2013}35)

### Output column names

* `--col_cluster` (default: `ICLUSTER`)
* `--col_member`  (default: `IMEMBER`)
* `--col_mode`    (default: `CL_MODE`)
* `--col_reason`  (default: `CL_REASON`)

### Diagnostics

* `-d / --debug`
  Verbose debug output
* `--figdir`
  Directory for diagnostic plots (default: `fig_cluster`)
* `--show`
  Show plots interactively (optional)

### Tunable parameters (defaults are encoded in the script)

* `--threshold_large` (default: 12235)
* `--interval_limit` (default: 40)
* `--SECOND_THRES_USE_LEN` (default: 75)
* `--rt_min` (default: 32)
* `--rt_max` (default: 58)
* `--mjdref` (default: 58484)

---

## Clustering Modes: Large vs Small

### Large mode

Designed to detect **macroscopic particle-induced events**, where a large pulse is a reliable indicator of a non-astrophysical trigger.

**Start condition (conceptual)**

* `ITYPE == Lp` and `LO_RES_PH > threshold_large`

Interpretation:

> Clusters anchored by a large-amplitude Lp are **unlikely to be astrophysical** and should be treated as suspect.

### Small mode

Optimized for detecting **subtle pseudo events**, including waveform subtraction residual triggers and special forced-trigger populations.

**Start condition (conceptual)**

* `ITYPE == Lp`, `LO_RES_PH <= threshold_large`
* and either:

  * short `NEXT_INTERVAL` (< `interval_limit`), or
  * special `NEXT_INTERVAL == 75`, or
  * special `NEXT_INTERVAL == 105`
* and rise-time anomaly (outside [`rt_min`, `rt_max`])

This mode is essential for understanding **Ls contamination**, which can be invisible to standard screening.

---

## Output

The output FITS file contains additional columns in the EVENTS extension.
No events are removed automatically.

### Primary annotation columns

* `ICLUSTER` (or `--col_cluster`)
  **Cluster ID** (`0` means not clustered).
  In the current implementation, `ICLUSTER` is defined as the **start-row index within the pixel stream**.
  All rows belonging to the same cluster share the same non-zero ID.

* `IMEMBER` (or `--col_member`)
  **Member index** within the cluster (`1..N`).
  `0` means not clustered.

* `CL_MODE` (or `--col_mode`)
  Mode code applied in the current run:
  `0` none, `1` large, `2` small.

* `CL_REASON` (or `--col_reason`)
  Bitmask encoding which conditions were satisfied and whether the row was used as:

  * a **cluster START** (START_OK), or
  * a **cluster CONTINUATION** (CONT_OK)

### Additional debug columns

* `PREV_LO_RES_PH`
* `PREV_ITYPE`

These are included to support local-context debugging and quick validation.

---

## Notes and Limitations

* This tool **annotates**; it does not reject events.
* Extremely high-rate conditions may break algorithmic assumptions (isolated-pulse premise).
* Some pseudo events may survive if their parent event is lost due to saturation or CPU drop.

---

# 7. Taxonomy of Pseudo Ls Events (Critical Section)

This section describes **five distinct classes of pseudo Ls events** that appear as Ls in Resolve data but are **not astrophysical X-ray photons**.

These categories are based on **timing structure, waveform behavior, and algorithmic response**, and are critical for **correct exposure and grade interpretation**.

---

## (1) Cosmic-ray\UTF{2013}induced pseudo Ls following a large pulse

**Description**
Pseudo Ls events generated immediately after a **very large pulse**, typically caused by a cosmic-ray interaction.

**Key signatures**

* Very short `NEXT_INTERVAL` (typically \UTF{2248} 25 samples)
* Often appears as a **single Lp + Ls pair**
* In some pixels, **one Lp followed by multiple Ls** may occur

**Physical origin**

* Occurs not only for fully clipped pulses, but also for **semi-clipped large-amplitude waveforms**
* Residuals from imperfect waveform subtraction satisfy the Ls trigger condition shortly after the primary event

**Interpretation**

> Cosmic-ray\UTF{2013}induced clipped or semi-clipped events producing artificial secondary triggers

---

## (2) Frame-event\UTF{2013}induced small-amplitude pseudo Ls

**Description**
Pseudo Ls events induced by **charged-particle hits on the readout board or frame**, rather than the absorber.

**Key signatures**

* Small waveform amplitude
* Very short effective time constant
* Typically appears as a **single Lp + Ls pair**

**Physical origin**

* Residual mismatch between the actual waveform and the subtraction template
* Residual crosses the Ls trigger threshold despite small absolute amplitude

**Operational impact**

> Often appears harmless, but **degrades event grading and effective exposure**

---

## (3) High-rate\UTF{2013}induced abnormal Lp/Ls (waveform subtraction breakdown)

**Description**
Occurs under **high event-rate conditions**, independent of cosmic-ray hits.

**Key signatures**

* Primary waveform subtraction becomes unstable
* Irregular increase of apparent Lp/Ls events
* Temporal patterns become non-Poissonian

**Physical origin**

* Breakdown of the algorithmic assumption of **isolated pulses**
* Errors in average waveform subtraction accumulate

**Interpretation**

> Purely algorithmic limitation, not a detector or physics issue

---

## (4) Pseudo Lp/Ls with NEXT_INTERVAL == 75

**Description**
A population of events clustered at **exactly 75 samples** in `NEXT_INTERVAL`.

**Key signatures**

* Waveforms are not obviously clipped
* Appear similar to nominal events
* Small but systematic residuals remain after subtraction

**Mechanism**

* Residual amplitude is too small to exceed `deriv_max / SECOND_THRES_FRAC`
* Trigger does not fire immediately
* Forced trigger occurs after `SECOND_THRES_USE_LEN = 75` samples

**Interpretation**

> Pseudo events generated by subtle but systematic deviations from the average waveform

---

## (5) Pseudo Lp/Ls with NEXT_INTERVAL == 105 (large amplitude, fast decay)

**Description**
Anomalous events concentrated at **NEXT_INTERVAL == 105**.

**Key signatures**

* Only appears for large-amplitude waveforms
* Rise time \UTF{2248} 25\UTF{2013}26 samples
* Effectively **abnormally fast decay in the derivative waveform**
* `slope_differ == 1`

**Physical origin**

* Large deviation from the average derivative waveform
* Produces large residuals that satisfy secondary trigger logic

**Interpretation**

> Special combination of large amplitude and non-standard decay behavior

--- 

--- 



## Appendix A — Implementation Details (resolve_ftools_detect_pseudo_event_clusters.py)

This appendix documents the implementation of the Resolve pseudo-event clustering tool:

* **Per-pixel processing** (each pixel stream is clustered independently)
* **Non-destructive annotation** (no event removal; FITS rows preserved)
* **Traceable diagnostics** via:

  * `CL_MODE` (which clustering mode was applied)
  * `CL_REASON` (bitmask indicating which conditions were satisfied and whether the row was used as START/CONT)

### A.1 Inputs and required event columns

The script expects an event FITS file with a binary table in **HDU=1** (commonly `EVENTS`). At minimum, the clustering logic uses:

* `PIXEL` (pixel ID)
* `TIME` (seconds since MJD reference)
* `ITYPE` (event type, where this code assumes **Lp=3**, **Ls=4**)
* `LO_RES_PH` (low-res pulse height / proxy for amplitude)
* `NEXT_INTERVAL` (sample count to the next trigger)
* `PREV_INTERVAL` (sample count from the previous trigger)
* `RISE_TIME` (rise-time metric)

The script adds or replaces these output columns:

* cluster columns:

  * `ICLUSTER` (configurable name via `--col_cluster`)
  * `IMEMBER` (via `--col_member`)
  * `CL_MODE` (via `--col_mode`)
  * `CL_REASON` (via `--col_reason`)
* diagnostics:

  * `PREV_LO_RES_PH`
  * `PREV_ITYPE`

> Note: prior-interval columns (`PREV_INTERVAL`, `NEXT_INTERVAL`) are assumed to already exist, typically generated by a preceding step (e.g., `resolve_ftools_add_prevnext.sh`). 

---

### A.2 Design principles

#### (1) “True cluster ID” = start row index within that pixel stream

Within each pixel stream, clusters are assigned a stable ID:

* `cluster_id = i` where `i` is the **row index (0-based) within that pixel’s event array** at the moment a cluster starts.

As a result:

* all rows belonging to the same cluster share the same `cluster_id`
* cluster IDs are stable and reproducible for the same input ordering

This is explicitly implemented here: `cluster_id = i` at the start condition. 

#### (2) Member index is 1..N within each cluster

* The cluster start row has `IMEMBER = 1`
* Each continuation row increments the member count (`2, 3, …`) 

#### (3) CL_MODE and CL_REASON provide traceability

* `CL_MODE` tells you whether this pass was run in large or small mode (1 or 2).
* `CL_REASON` is a **bitmask** encoding:

  * which start-condition flags were true (e.g., `ITYPE==Lp`, `LO_RES_PH > threshold`, `NEXT_INTERVAL < limit`, etc.)
  * whether the row was used as a **cluster START** or **cluster CONT** 

This is critical in flight-style review contexts: every clustered row is explainable as a set of boolean conditions, not a black box.

---

### A.3 Parameter set (`Params`) and defaults

The clustering uses a `Params` dataclass (immutable) for reproducibility:

* `threshold_large` (default 12235)
* `interval_limit` (default 40)
* `SECOND_THRES_USE_LEN` (default 75)
* `SECOND_THRES_UNKNOWN` (default 105)
* `rt_min`, `rt_max` (default 32, 58)
* `mjdref` (default 58484)

These are set from CLI args, then passed into `identify_clusters()` for each pixel. 

> Note: `threshold_small` exists as a placeholder (reserved for future tuning), but is currently unused in the clustering start logic. 

---

### A.4 CL_REASON bitmask definition

The code defines explicit bit indices (start-condition-related, continue-condition-related, and outcome flags). For example:

* `BIT_IS_LP` (0): `ITYPE == 3`
* `BIT_IS_LS` (1): `ITYPE == 4`
* `BIT_LO_GT_LARGE` (2): `LO_RES_PH > threshold_large`
* `BIT_NT_LT_LIMIT` (4): `NEXT_INTERVAL < interval_limit`
* `BIT_NT_EQ_SECONDTHRES` (5): `NEXT_INTERVAL == 75` (special)
* `BIT_START_OK` (14): row used as cluster start
* `BIT_CONT_OK` (15): row used as cluster continuation 

The helper `_setbit(x, bit)` is used to OR a bit into an integer mask. 

#### Interpreting CL_REASON

In downstream analysis, to test a bit:

* `(CL_REASON >> bit) & 1 == 1`

The script provides `_hasbit()` for vectorized checks in cluster statistics plots. 

---

### A.5 Core algorithm: identify_clusters(events, mode, params)

`identify_clusters()` processes **one pixel stream** (`events` already filtered to a single pixel) and returns arrays aligned to that pixel stream. 

#### A.5.1 Per-row diagnostic bits are computed unconditionally

For each row `i`, the script computes a baseline `reason` mask from:

* ITYPE (Lp/Ls)
* LO_RES_PH threshold comparisons
* NEXT_INTERVAL checks
* RISE_TIME range checks

These diagnostic bits are stored even if the row is not clustered, so you can inspect “near misses” later. 

#### A.5.2 Cluster start conditions

**Large mode start condition**
A cluster starts when the row is:

* `ITYPE == 3` (Lp)
* `LO_RES_PH > threshold_large` 

This reflects the operational idea: “large amplitude Lp is the trigger anchor for a likely particle-induced cluster.”

**Small mode start condition**
A cluster starts when the row is:

* `ITYPE == 3` (Lp)
* `LO_RES_PH <= threshold_large` (i.e., not “large”)
* `NEXT_INTERVAL` satisfies at least one of:

  * `< interval_limit` (e.g., < 40)
  * `== 75` (PSP special forced-trigger length)
  * `== 105` (the “unknown/special” group encoded as `SECOND_THRES_UNKNOWN`)
* and `RISE_TIME` is out of nominal range:

  * `< rt_min` OR `> rt_max` 

This matches the intent: catch subtle pseudo behaviors that manifest as short-following triggers or forced-trigger populations with abnormal rise times.

#### A.5.3 Cluster continuation condition

Once a cluster starts, continuation includes subsequent rows while:

* `ITYPE in (3,4)` (Lp or Ls)
* and `PREV_INTERVAL` is either:

  * `< interval_limit` OR `== 75` OR `== 105` 

Continuation rows are marked with `BIT_CONT_OK`, and their `IMEMBER` increments. 

#### A.5.4 Previous-row diagnostics

After clustering, the function constructs:

* `PREV_LO_RES_PH[k] = LO_RES_PH[k-1]`
* `PREV_ITYPE[k] = ITYPE[k-1]`

for debugging and quick “local context” checks. 

---

### A.6 Per-pixel → global arrays: process_pixel_data()

`process_pixel_data()` wraps `identify_clusters()` and returns arrays aligned to the full FITS table length:

1. Make `pixel_mask = (data["PIXEL"] == pixel)`
2. Cluster only `pixel_events = data[pixel_mask]`
3. Allocate global arrays of length `n_rows`
4. Fill only masked rows with the per-pixel results 

This ensures the output columns align with the original FITS row ordering and can be written directly into HDU=1.

---

### A.7 Diagnostics and visualization outputs

When `--figdir` is provided (default `fig_cluster`), the script generates:

#### A.7.1 Per-pixel cluster overview plot

`plot_cluster()` saves:

* TIME vs LO_RES_PH (Lp, Ls, and highlighted clustered Lp/Ls)
* NEXT_INTERVAL vs LO_RES_PH (with clustered points highlighted)

Output filename:

* `cluster_summary_{outname}_pixel{pixel}.png` 

#### A.7.2 CL_REASON visualization + cluster statistics

`plot_cluster_stats_for_pixel()` produces:

* cluster size histogram
* CL_REASON bit frequency bar chart (clustered rows only)
* heatmap: (top-N clusters) × (bits) showing per-cluster bit fractions
* consistency check (Lp/Ls vs START/CONT mapping)
* CSV summary per cluster: `...cluster_stats_pixel{pixel}.csv`

This module is designed to make it immediately obvious whether the clustering is behaving as expected and whether unexpected patterns exist. 

---

### A.8 FITS column replacement strategy (overwrite-safe)

Before writing output, the script **removes pre-existing columns** with the same names to avoid FITS overwrite errors:

* removes `PREV_LO_RES_PH`, `PREV_ITYPE`, and any user-specified output column names
* then appends the newly computed columns 

---

## Appendix B — Flow Chart (Mermaid)

Paste the following Mermaid block into your README. It summarizes the full pipeline inside this script (argument parsing → per-pixel clustering → plots → FITS write).

```mermaid
flowchart TD
  A[Start] --> B[Parse CLI arguments]
  B --> C[Build Params dataclass]
  C --> D[Ensure figdir exists]
  D --> E[Open input FITS (HDU=1 EVENTS)]
  E --> F[Allocate global output arrays\nICLUSTER, IMEMBER, CL_MODE, CL_REASON,\nPREV_LO_RES_PH, PREV_ITYPE]

  F --> G[Parse pixel list (--usepixels)]
  G --> H{For each pixel}

  H --> I[Filter rows: pixel_mask = (PIXEL == pixel)]
  I --> J[pixel_events = data[pixel_mask]]

  J --> K[identify_clusters(pixel_events, mode, params)]
  K --> K1[Compute per-row diagnostic bits\n(ITYPE, LO, NEXT, RISE)]
  K1 --> K2{Start condition met?}

  K2 -- No --> K3[Mark cl_mode/cl_reason baseline\n(no clustering)]
  K3 --> K4[Advance i]
  K4 --> K1

  K2 -- Yes --> L[Start cluster:\ncluster_id = i\nmember_id = 1\nset START_OK bit]
  L --> M{Continuation condition holds?}
  M -- Yes --> N[Assign same cluster_id\nmember_id++\nset CONT_OK bit\nadvance i]
  N --> M
  M -- No --> O[Exit cluster loop]

  O --> P[Compute PREV_LO_RES_PH / PREV_ITYPE arrays]
  P --> Q[Return per-pixel arrays\n(cluster_ids, member_ids,\ncl_mode, cl_reason,\nprev_lo, prev_itype)]

  Q --> R[Map per-pixel arrays into global arrays\n(only pixel_mask rows)]
  R --> S{figdir enabled?}
  S -- Yes --> T[plot_cluster()\nTIME vs LO and NEXT vs LO]
  T --> U[plot_cluster_stats_for_pixel()\nCSV + size hist + bit freq + heatmap + consistency]
  S -- No --> V[Skip plots]

  U --> W[Next pixel]
  V --> W
  W --> H

  H -->|All pixels processed| X[Remove existing columns if name-collisions]
  X --> Y[Append new columns\nICLUSTER/IMEMBER/CL_MODE/CL_REASON\nPREV_LO_RES_PH/PREV_ITYPE]
  Y --> Z[Write output FITS (overwrite=True)]
  Z --> AA[End]
```

---

### Appendix C — Practical interpretation guide (quick)

* Use `ICLUSTER > 0` to identify candidate pseudo-event groups.
* Use `IMEMBER` to identify cluster structure (start vs subsequent members).
* Use `CL_REASON` to separate:

  * forced-trigger populations (`NEXT==75` or `NEXT==105`)
  * short-interval chains (`NEXT<40` or `PREV<40`)
  * rise-time anomalies (`RISE<rt_min` or `RISE>rt_max`)
* Use `CL_MODE` to distinguish large-mode vs small-mode tagging.



## Remark

This tool provides **diagnostic transparency**, not automatic decisions.
Correct scientific conclusions require **physical interpretation of clustered Ls**, not blind filtering.
